---
{"dg-publish":true,"permalink":"/数据结构/链表/"}
---


### 概述

**定义**

在计算机科学中，链表是一种线性结构的数据结构（长的像一条线），是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续

可以分类为5

- 单向链表，每个元素只知道其下一个元素是谁
    
![Pasted image 20240118223423.png](/img/user/pic/Pasted%20image%2020240118223423.png)

- 双向链表，每个元素知道其上一个元素和下一个元素
    
![Pasted image 20240118223558.png](/img/user/pic/Pasted%20image%2020240118223558.png)

- 循环链表，通常的链表尾节点 tail 指向的都是 null，而循环链表的 tail 指向的是头节点 head3538273.png?lastModify=1705586860)
	![Pasted image 20240118223521.png](/img/user/pic/Pasted%20image%2020240118223521.png)

链表内还有一种特殊的节点称为哨兵（Sentinel）节点，也叫做哑元（ Dummy）节点，它不存储数据，通常用作头尾，用来简化边界判断，如4611550.png?lastModify=1705586860)
![Pasted image 20240118223524.png](/img/user/pic/Pasted%20image%2020240118223524.png)

#### **随机访问性能**

根据 index 查找，时间复杂度 $O(n)$

#### **插入或删除性能**

- 起始位置：$O(1)$
    
- 结束位置：如果已知 tail 尾节点是 $O(1)$，不知道 tail 尾节点是 $O(n)$
    
- 中间位置：根据 index 查找时间 + $O(1)$



### 单向链表

根据单向链表的定义，首先定义一个存储 value 和 next 指针的类 Node，和一个描述头部节点的引用
```java
public class SinglyLinkedList {
    
    private Node head; // 头部节点
    
    private static class Node { // 节点类
        int value;
        Node next;

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }
    }
}
```

- Node 定义为内部类，是为了对外**隐藏**实现细节，没必要让类的使用者关心 Node 结构
    
- 定义为 static 内部类，是因为 Node **不需要**与 SinglyLinkedList 实例相关，多个 SinglyLinkedList实例能共用 Node 类定义

#### 头部添加

#### 遍历
#### 尾部添加
#### 获取指定位置

#### 头部删除

#### 删除指定位置

#### 哨兵


### 双向链表（带哨兵）

```java
public class DoublyLinkedListSentinel implements Iterable<Integer> {

    private final Node head;
    private final Node tail;

    public DoublyLinkedListSentinel() {
        head = new Node(null, 666, null);
        tail = new Node(null, 888, null);
        head.next = tail;
        tail.prev = head;
    }

    static class Node {
        Node prev;
        int value;
        Node next;

        public Node(Node prev, int value, Node next) {
            this.prev = prev;
            this.value = value;
            this.next = next;
        }
    }
	...
	...
}
```


### 环形链表（带哨兵）
双向环形链表带哨兵，这时哨兵**既作为头，也作为尾**

![Pasted image 20240122162815.png](/img/user/pic/Pasted%20image%2020240122162815.png)

![Pasted image 20240122162820.png](/img/user/pic/Pasted%20image%2020240122162820.png)

![Pasted image 20240122162825.png](/img/user/pic/Pasted%20image%2020240122162825.png)

![Pasted image 20240122162833.png](/img/user/pic/Pasted%20image%2020240122162833.png)

```java
public class DoublyLinkedListSentinel implements Iterable<Integer> {

	private final Node sentinel = new Node(null, -1, null); // 哨兵

    public DoublyLinkedListSentinel() {
        sentinel.next = sentinel;
        sentinel.prev = sentinel;
    }
	static class Node {
        Node prev;
        int value;
        Node next;

        public Node(Node prev, int value, Node next) {
            this.prev = prev;
            this.value = value;
            this.next = next;
        }
    }
	...
	...
}
```


### 应用

#### 反转单向链表-力扣 206 题

对应力扣题目 [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

```
输入：head = [1,2,3,4,5]  
输出：[5,4,3,2,1]  
​  
输入：[1,2]  
输出：[2,1]  
​  
输入：[]  
输出：[]
```


**方法1**

构造一个新链表，从**旧链表**依次拿到每个节点，创建新节点添加至**新链表**头部，完成后新链表即是倒序的
```java
public ListNode reverseList(ListNode o1) {  
    ListNode n1 = null;  
    ListNode p = o1;  
    while (p != null) {  
        n1 = new ListNode(p.val, n1);  
        p = p.next;  
    }  
    return n1;  
}
```

评价：简单直白，就是得新创建节点对象

**方法2**

与方法1 类似，构造一个新链表，从**旧链表头部**移除节点，添加到**新链表头部**，完成后新链表即是倒序的，区别在于原题目未提供节点外层的容器类，这里提供一个，另外一个区别是并不去构造新节点

```java
static class List {
    ListNode head;

    public List(ListNode head) {
        this.head = head;
    }

    public ListNode removeFirst(){
        ListNode first = head;
        if (first != null) {
            head = first.next;
        }
        return first;
    }

    public void addFirst(ListNode first) {
        first.next = head;
        head = first;
    }
}
```


```java
public ListNode reverseList(ListNode head) {
    List list1 = new List(head);
    List list2 = new List(null);
    ListNode first;
    while ((first = list1.removeFirst()) != null) {
        list2.addFirst(first);
    }
    return list2.head;
}
```
评价：更加面向对象，如果实际写代码而非刷题，更多会这么做

**方法3**

递归，在**归**时让 $5 \rightarrow 4$，$4 \rightarrow 3$ ...

代码：
```java
public ListNode reverseList(ListNode p) {    
    if (p == null || p.next == null) { // 不足两个节点
        return p; // 最后一个节点
    }
    ListNode last = reverseList(p.next);
    p.next.next = p;
    p.next = null;
    return last;
}
```

- 注意1：递归终止条件是 curr.next == null，目的是到最后一个节点就结束递归，与之前递归遍历不一样
- 注意2：需要考虑空链表即 p == null 的情况


**方法4**

从链表每次拿到第二个节点，将其从链表断开，插入头部，直至它为 null 结束

1. 设置指针 o1(旧头)、n1(新头)、o2(旧老二)，分别指向第一，第一，第二节点
	$\frac{n1 \ o1}{1} \rightarrow \frac{o2}{2} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow null$
2. 将 o2 节点从链表断开，即 o1 节点指向第三节点
    $\frac{n1 \ o1}{1} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow null$ ，$\frac{o2}{2}$
3. o2 节点链入链表头部，即
	$\frac{o2}{2} \rightarrow \frac{n1 \ o1}{1} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow null$
4. n1 指向 o2
    $\frac{n1 \ o2}{2} \rightarrow \frac{o1}{1} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow null$
5. o2 指向 o1 的下一个节点，即
    $\frac{n1}{2} \rightarrow \frac{o1}{1} \rightarrow \frac{o2}{3} \rightarrow 4 \rightarrow 5 \rightarrow null$
6. 重复以上 $2\sim5$ 步，直到 o2 指向 null
7. 还应当考虑边界条件，即链表中不满两个元素时，无需走以上逻辑

```java
public ListNode reverseList(ListNode o1) {    
    if (o1 == null || o1.next == null) { // 不足两个节点
        return o1;
    }
    ListNode o2 = o1.next;
    ListNode n1 = o1;
    while (o2 != null) {
        o1.next = o2.next; 
        o2.next = n1;
        n1 = o2;
        o2 = o1.next;
    }
    return n1;
}
```

**方法5**

要点：把链表分成两部分，思路就是不断从链表2的头，往链表1的头搬移

1. n1 指向 null，代表**新链表**一开始没有元素，o1 指向**原链表**的首节点
    $\frac{n1}{null}$，$\frac{o1}{1} \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow null$

2. 开始循环，o2 指向**原链表**次节点
    $\frac{n1}{null}$，$\frac{o1}{1} \rightarrow \frac{o2}{2} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow null$

3. 搬移
    $\frac{o1}{1} \rightarrow \frac{n1}{null}$ ， $\frac{o2}{2} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow null$

4. 指针复位
    $\frac{n1}{1} \rightarrow null$ ， $\frac{o1 \ o2}{2} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow null$

5. 重复 $2\sim4$ 步
    
6. 当 o1 = null 时退出循环

代码
```java
public ListNode reverseList(ListNode o1) {
    if (o1 == null || o1.next == null) {
        return o1;
    }
    ListNode n1 = null;
    while (o1 != null) {
        ListNode o2 = o1.next;
        o1.next = n1;
        n1 = o1;
        o1 = o2;
    }
    return n1;
}
```

评价：本质上与方法2 相同，只是方法2更为面向对象