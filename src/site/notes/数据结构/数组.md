---
{"dg-publish":true,"permalink":"/数据结构/数组/"}
---

## 定义

在计算机科学中，数组是由一组元素（值或变量）组成的数据结构，每个元素有至少一个索引或键来标识

因为数组内的元素是**连续存储**的，所以数组中元素的地址，可以通过其索引计算出来，例如：

```java
int[] array = {1,2,3,4,5}
```

知道了数组的**数据**起始地址$BaseAddress$，就可以由公式 $BaseAddress + i * size$ 计算出索引 $i$ 元素的地址

- $i$ 即索引，在 Java、C 等语言都是从 0 开始
    
- $size$ 是每个元素占用字节，例如 $int$ 占 $4$，$double$ 占 $8$

**小测试**

```
byte[] array = {1,2,3,4,5}
```

已知 array 的**数据**的起始地址是 0x7138f94c8，那么元素 3 的地址是什么？

> 答：0x7138f94c8 + 2 * 1 = 0x7138f94ca

## 空间占用

Java 中数组结构为

- 8 字节 markword
- 4 字节 class 指针（压缩 class 指针的情况）
- 4 字节 数组大小（决定了数组最大容量是 $2^{32}$）
- 数组元素 + 对齐字节（java 中所有对象大小都是 8 字节的整数倍12，不足的要用对齐字节补足）


例如

```
int[] array = {1, 2, 3, 4, 5};
```

的大小为 40 个字节，组成如下

```
8 + 4 + 4 + 5*4 + 4(alignment)
```

**随机访问性能**

即根据索引查找元素，时间复杂度是 $O(1)$


## 二维数组

```java
int[][] array = {
    {11, 12, 13, 14, 15},
    {21, 22, 23, 24, 25},
    {31, 32, 33, 34, 35},
};
```

内存图如下

![image-20221104114132056.png](/img/user/pic/image-20221104114132056.png)


- 二维数组占 32 个字节，其中 array[0]，array[1]，array[2] 三个元素分别保存了指向三个一维数组的引用
    
- 三个一维数组各占 40 个字节
    
- 它们在内层布局上是**连续**的
    

更一般的，对一个二维数组 $Array[m](#)$

- $m$ 是外层数组的长度，可以看作 row 行
    
- $n$ 是内层数组的长度，可以看作 column 列
    
- 当访问 $Array[i](#)$，$0\leq i \lt m, 0\leq j \lt n$时，就相当于
    
    - 先找到第 $i$ 个内层数组（行）
        
    - 再找到此内层数组中第 $j$ 个元素（列）


**小测试**

Java 环境下（不考虑类指针和引用压缩，此为默认情况），有下面的二维数组

```java
byte[][] array = {  
    {11, 12, 13, 14, 15},  
    {21, 22, 23, 24, 25},  
    {31, 32, 33, 34, 35},  
};
```

已知 array **对象**起始地址是 0x1000，那么 23 这个元素的地址是什么？

> 答：
> 
> - 起始地址 0x1000
>     
> - 外层数组大小：16字节对象头 + 3元素 * 每个引用4字节 + 4 对齐字节 = 32 = 0x20
>     
> - 第一个内层数组大小：16字节对象头 + 5元素 * 每个byte1字节 + 3 对齐字节 = 24 = 0x18
>     
> - 第二个内层数组，16字节对象头 = 0x10，待查找元素索引为 2
>     
> - 最后结果 = 0x1000 + 0x20 + 0x18 + 0x10 + 2*1 = 0x104a


### 局部性原理

这里只讨论空间局部性

- cpu 读取内存（速度慢）数据后，会将其放入高速缓存（速度快）当中，如果后来的计算再用到此数据，在缓存中能读到的话，就不必读内存了
    
- 缓存的最小存储单位是缓存行（cache line），一般是 64 bytes，一次读的数据少了不划算啊，因此最少读 64 bytes 填满一个缓存行，因此读入某个数据时也会读取其**临近的数据**，这就是所谓**空间局部性**


**对效率的影响**
- 缓存是有限的，当新数据来了后，一些旧的缓存行数据就会被覆盖
    
- 如果不能充分利用缓存的数据，就会造成效率低下

**举一反三**

1. I/O 读写时同样可以体现局部性原理
    
2. 数组可以充分利用局部性原理，那么链表呢？
    
    > 答：链表不行，因为链表的元素并非相邻存储