---
{"dg-publish":true,"permalink":"/数据结构/递归/"}
---

## 定义
程序调用自身编程技巧

一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。

## 递归的应用条件

构成递归需要具备如下条件：
1. 子问题必须与原始问题为同样的事，且更为简单。
2. 问题解法按递归算法实现。
3. 数据结构的形式是按照递归定义的。如二叉树等，由于结构本身就有递归的特性，因此树也经常被用于递归形象化的模型。

## 递归的缺点
递归解决问题运行效率较低，因此应该尽量避免使用，除非没有更好的算法或者某种特定情况，递归更为合适的时候选择递归解决问题。在递归调用的过程中系统为每一层的返回点，局部变量等开辟了栈来储存，递归次数过多可能造成栈溢出。

## 递归思想的内涵

递归实际上是有去（递）有回（归）的。
“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决；“有回”是指 : 这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回到原点，原问题解决。

更直接地说，递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在。格外重要的是，这个解决问题的函数必须有明确的结束条件，否则就会导致无限递归的情况。

## 用数学归纳法来理解递归

递归的数学模型其实就是==数学归纳法==，这个在高中的数列里面是最常用的了，回忆一下数学归纳法。
数学归纳法适用于将解决的原问题转化为解决他的子问题，而它的子问题又变成子问题的子问题，而且我们发现这些问题其实都是一个模型，也就是说存在相同的逻辑归纳处理项。当然有一个是例外的，也就是归纳结束的那个处理方法不适用我们的归纳处理项，不然就无穷归纳了。总的来说，归纳法主要包含以下三个关键要素：
- 步进表达式：问题蜕变成子问题的表达式
- 结束条件：什么时候可以不再使用步进表达式
- 直接求解表达式：在结束条件下能够直接计算返回值的表达式
事实上，这也正是某些数列问题在利用编程的方式去解决时可以使用递归的原因。例如斐波那契数列问题。

## 递归的三要素

- 明确递归终止条件
- 给出递归终止时的处理办法
- 提取重复逻辑，缩小问题规模

## 递归模型
模型一：
```js
function recursion(){
	if(end_condition) //递归终止条件
		end;  //递归终止时处理方法
	else {
		solve: //递
		recursion(小问题) //递归到最深处，归来
	}
}
```
模型二：
```js
function recursion(){
	if(end_condition) //递归终止条件
		end;  //递归终止时处理方法
	else {
		recursion(小问题) //递归到最深处，归来
		solve: //递
	}
}
```
## 递归的应用场景

递归算法一般用于解决三类问题：
1. 问题的定义是按递归定义的（斐波那契函数,阶乘,...)
2. 问题的解法时递归的(有些问题只能使用递归方法来解决，例如，汉诺塔问题，....)
3. 数据结构是递归的(链表、树等操作，包含树的遍历，树的深度,...)
## 递归与循环的区别

递归实现转换成非递归实现一般需要二步工作：
1. 自己建立“堆栈（一些局部变量）”来保存这些内容以便代替系统栈，比如树的三种递归遍历方式
2. 把对递归的调用转变为对循环处理


```mermaid
flowchart TD
A(5) --> B[4]
A --> C[3]

```



