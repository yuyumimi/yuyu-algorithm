---
{"dg-publish":true,"permalink":"/数据结构/递归/"}
---

## 定义
程序调用自身编程技巧

一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。

## 递归的应用条件

==构成递归需要具备==如下条件：
1. 子问题必须与原始问题为同样的事，且更为简单。
2. 父问题的结果依赖于子问题的
3. 问题解法按递归算法实现。
4. 数据结构的形式是按照递归定义的。如二叉树等，由于结构本身就有递归的特性，因此树也经常被用于递归形象化的模型。

## 递归的缺点
递归解决问题运行效率较低，因此应该尽量避免使用，除非没有更好的算法或者某种特定情况，递归更为合适的时候选择递归解决问题。在递归调用的过程中系统为每一层的返回点，局部变量等开辟了栈来储存，递归次数过多可能造成栈溢出。

## 递归思想的内涵

递归实际上是有去（递）有回（归）的。
“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决；“有回”是指 : 这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回到原点，原问题解决。

更直接地说，递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在。格外重要的是，这个解决问题的函数必须有明确的结束条件，否则就会导致无限递归的情况。

## 用数学归纳法来理解递归

递归的数学模型其实就是==数学归纳法==，这个在高中的数列里面是最常用的了，回忆一下数学归纳法。
数学归纳法适用于将解决的原问题转化为解决他的子问题，而它的子问题又变成子问题的子问题，而且我们发现这些问题其实都是一个模型，也就是说存在相同的逻辑归纳处理项。当然有一个是例外的，也就是归纳结束的那个处理方法不适用我们的归纳处理项，不然就无穷归纳了。总的来说，归纳法主要包含以下三个关键要素：
- 步进表达式：问题蜕变成子问题的表达式
- 结束条件：什么时候可以不再使用步进表达式
- 直接求解表达式：在结束条件下能够直接计算返回值的表达式
事实上，这也正是某些数列问题在利用编程的方式去解决时可以使用递归的原因。例如斐波那契数列问题。

## 递归的三要素

- 明确递归终止条件
- 给出递归终止时的处理办法
- 提取重复逻辑，缩小问题规模

遍历链表的递推关系为

$$  
f(n) = \begin{cases} 停止& n = null \\ f(n.next) & n \neq null \end{cases}  
$$
  

- 深入到最里层叫做**递**
    
- 从最里层出来叫做**归**
    
- 在**递**的过程中，外层函数内的局部变量（以及方法参数）并未消失，**归**的时候还可以用到

## 递归模型
模型一：
```js
function recursion(){
	if(end_condition) //递归终止条件
		end;  //递归终止时处理方法
	else {
		solve: //递
		recursion(小问题) //递归到最深处，归来
	}
}
```
模型二：
```js
function recursion(){
	if(end_condition) //递归终止条件
		end;  //递归终止时处理方法
	else {
		recursion(小问题) //递归到最深处，归来
		solve: //递
	}
}
```
## 递归的应用场景

递归算法一般用于解决三类问题：
1. 问题的定义是按递归定义的（斐波那契函数,阶乘,...)
2. 问题的解法时递归的(有些问题只能使用递归方法来解决，例如，汉诺塔问题，....)
3. 数据结构是递归的(链表、树等操作，包含树的遍历，树的深度,...)
## 递归与循环的区别

递归实现转换成非递归实现一般需要二步工作：
1. 自己建立“堆栈（一些局部变量）”来保存这些内容以便代替系统栈，比如树的三种递归遍历方式
2. 把对递归的调用转变为对循环处理



## 递归的应用



> [!NOTE] 递推求阶乘
> 

- 阶乘的定义 $n!= 1⋅2⋅3⋯(n-2)⋅(n-1)⋅n$，其中 $n$ 为自然数，当然 $0! = 1$
    
- 递推关系

$$ 
f(n) = 
\begin{cases}
1 & n = 1\\
n * f(n-1) & n > 1
\end{cases}
$$
```java
public class ReversePrintString {  
 
	public void r(String str, int n) {
		int len = str.length();
		if (len == n) {
			return;
		}
		r(str, n + 1);
		System.out.println(str.charAt(n));
	}
}
```


### 斐波那契数列


### 爬楼梯问题


> [!NOTE] 爬楼梯问题
> 一个楼梯总共有n阶台阶，问从第0阶台阶走到第n阶台阶一共有多少中方案。你每次可以走一个台阶或者俩个台阶

假设5阶台阶，第一步可以走一阶台阶或者两阶：

```mermaid
flowchart TD

A(5阶台阶) --> B[1]
A --> C[2]
B --> D[2]
B --> E[3]
C --> F[3]
C --> G[4]
D --> H[3]
D --> I[4]
E --> L[4]
E --> M[5]
F --> N[4]
F --> O[5]
G --> p[5]
H --> Q[4]
H --> S[5]
I --> T[5]
L --> u[5]
N --> v[5]
Q --> w[5]


```


```java
public class Test {
  private static int n;
  private static int result = 0;
  public static void main(String[] args) {
    n = 5;
    int s = dfs(0);
    System.out.println("asdf：" + s);
  }

  private static int dfs(int u) {
    if (u == 5) {
      result++;
    }
    if (u < n) {
      dfs(u + 1);
      dfs(u + 2);
    }
    return result;
  }
}
```

### 全排列

> [!NOTE] 全排列
> 给定一个不含重复数字的数组nums，返回其所有可能的全排列，你可以按任意顺序返回答案

例如：
```
输入：nums=[1,2,3]
输出：[[123],[132],[213],[231],[312],[321]]
```



```mermaid
flowchart TD

A(1,2,3) -->|1加入到list| B[1]
A --> C[2]
A --> D[3]
B -->|2加入到list| E[12]
B--> F[13]
C --> G[21]
C --> H[23]
D --> I[31]
D --> L[32]
E -->|3加入到list| M[123]
F --> N[132]
G --> O[213]
H --> p[231]
I --> T[312]
L --> u[321]



```


```java
public class Solution{
  List<List<Integer>> result = new ArrayList();//存储全排列结果
  boolean stat[];//判断当前数字有没有用过
  List<Integer> path = new ArrayList();//存每一个方案数组
private List<List<Integer>> permute(int[] nums) {

    int n = nums.length;
    stat = new boolean[n];
    dfs(0, nums);
    return null;
  }

  private void dfs(int u, int[] nums) {
  //如果所有数都用过，说明找到了一组方案
    if (u == nums.length) {
      result.add(new ArrayList<>(path));
      return;
    }
  //否则，就循环遍历数组
    for (int i = 0; i < nums.length; i++) {
      if (!stat[i]) {//判断当前数字是否用过
        path.add(nums[i]);
        stat[i] = true;//加入到方案数组后，标记当前数字被用过
        dfs(u + 1, nums);
        // 回溯
        stat[i] = false;
        path.remove(path.size() - 1);
      }
    } 
  }
}
```

### 有重复数字的全排列


> [!NOTE] 有重复数字的全排列
> 给定一个含重复数字的数组nums，返回其所有可能的全排列，你可以按任意顺序返回答案

例如：
```
输入：nums=[1,1,2]
输出：[[112],[121],[211]]
```



```mermaid
flowchart TD

A(1,1,2) -->|1加入到list| B[1]
A --> C[2]
B -->|1加入到list| E[11]
B --> H[12]
E-->|2加入到list| F[112]
H--> I[121]
C --> G[21]
G --> M[211]

```

```java
public class Solution{
  List<List<Integer>> result = new ArrayList();//存储全排列结果
  boolean stat[];//判断当前数字有没有用过
  List<Integer> path = new ArrayList();//存每一个方案数组
private List<List<Integer>> permute(int[] nums) {

    int n = nums.length;
    stat = new boolean[n];
    dfs(0, nums);
    return null;
  }

  private void dfs(int u, int[] nums) {
  //如果所有数都用过，说明找到了一组方案
    if (u == nums.length) {
      result.add(new ArrayList<>(path));
      return;
    }
  //否则，就循环遍历数组
    for (int i = 0; i < nums.length; i++) {
      if (!stat[i]) {//判断当前数字是否用过
	    if (i > 0 && nums[i] == nums[i - 1] && !stat[i - 1]) {
		  continue;
	    }
        path.add(nums[i]);
        stat[i] = true;//加入到方案数组后，标记当前数字被用过
        dfs(u + 1, nums);
        // 回溯
        stat[i] = false;
        path.remove(path.size() - 1);
      }
    } 
  }
}
```

